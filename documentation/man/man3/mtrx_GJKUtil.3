.TH "mtrx::GJKUtil" 3 "Sat Dec 7 2019" "MTRX Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mtrx::GJKUtil \- Utility class for the implementation of the GJK algorithm used for collision detection between convex shape colliders\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <GJKUtil\&.h>\fP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>, typename Iterator1 , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator1>::value_type>::value>> static bool \fBCollision\fP (const Iterator &startVertices1, const Iterator &endVertices1, const Iterator1 &startVertices2, const Iterator1 &endVertices2)"
.br
.RI "Implementation of GJK Collision detection algorithm\&. "
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBUpdateSimplex\fP (\fBSimplex\fP &simplex, glm::vec3 &direction, glm::vec3 &a)"
.br
.RI "Update the simplex values or return a collision\&. "
.ti -1c
.RI "static bool \fBTriangleSimplexUpdate\fP (\fBSimplex\fP &simplex, glm::vec3 &direction, glm::vec3 &a)"
.br
.RI "Updating the simplex values from a triangle simplex\&. "
.ti -1c
.RI "static bool \fBTetrahedronSimplexUpdate\fP (\fBSimplex\fP &simplex, glm::vec3 &direction, glm::vec3 &a)"
.br
.RI "Update the simplex based upon a tetrahedron simplex\&. "
.ti -1c
.RI "static void \fBTetrahedronChecks\fP (\fBSimplex\fP &simplex, glm::vec3 &AO, glm::vec3 &AB, glm::vec3 &AC, glm::vec3 &ABC, glm::vec3 &direction, glm::vec3 &a)"
.br
.RI "Utility function for updating tetrahedron simplex knowing that there is no collision\&. "
.ti -1c
.RI "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>, typename Iterator1 , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator1>::value_type>::value>> static glm::vec3 \fBSupport\fP (const Iterator &startVertices1, const Iterator &endVertices1, const Iterator1 &startVertices2, const Iterator1 &endVertices2, const glm::vec3 &direction)"
.br
.RI "Support functionality for convex shape collider gives us a point in Minkowski space that is closest to the direction vector given\&. "
.ti -1c
.RI "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>> static glm::vec3 * \fBFarthestPointInDirection\fP (const Iterator &startVertices, const Iterator &endVertices, const glm::vec3 &direction)"
.br
.RI "Get a point in the vertex list that is closest (direction-wise) to the direction vector\&. "
.in -1c
.SH "Detailed Description"
.PP 
Utility class for the implementation of the GJK algorithm used for collision detection between convex shape colliders\&. 


.PP
\fBSee also\fP
.RS 4
\fBmtrx::ConvexShapeCollider\fP
.RE
.PP
Some resources on the algorithm:
.PP
\fBhttp://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/#gjk-minkowski  http://vec3.ca/gjk/implementation/  http://in2gpu.com/2014/05/18/gjk-algorithm-3d/ \fP
.SH "Member Function Documentation"
.PP 
.SS "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>, typename Iterator1 , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator1>::value_type>::value>> static bool mtrx::GJKUtil::Collision (const Iterator & startVertices1, const Iterator & endVertices1, const Iterator1 & startVertices2, const Iterator1 & endVertices2)\fC [inline]\fP, \fC [static]\fP"

.PP
Implementation of GJK Collision detection algorithm\&. 
.PP
\fBSee also\fP
.RS 4
\fBmtrx::ConvexShapeCollider\fP
.RE
.PP
\fBTemplate Parameters\fP
.RS 4
\fIIterator\fP The type of iterator we will use for vertices 
.br
\fIstd::enable_if_t<std::is_same<glm::vec3*,typename\fP std::iterator_traits<Iterator>::value_type>::value> Iterator template checks 
.br
\fIIterator1\fP The type of iterator we will use for vertices 
.br
\fIstd::enable_if_t<std::is_same<glm::vec3*,typename\fP std::iterator_traits<Iterator1>::value_type>::value> Iterator template checks 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstartVertices1\fP Iterator to the beginning of the first vertex list for first convex shape 
.br
\fIendVertices1\fP Iterator to the end of the first vertex list of the first convex shape 
.br
\fIstartVertices2\fP Iterator to the beginning of the second vertex list for the second convex shape 
.br
\fIendVertices2\fP Iterator to the end of the second vertex list of the second convex shape 
.br
 
.RE
.PP
\fBReturns\fP
.RS 4
true The 2 convex shape colliders collide 
.PP
false The 2 convex shape colliders do not collide 
.RE
.PP

.SS "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>> static glm::vec3* mtrx::GJKUtil::FarthestPointInDirection (const Iterator & startVertices, const Iterator & endVertices, const glm::vec3 & direction)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
Get a point in the vertex list that is closest (direction-wise) to the direction vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIIterator\fP The type of iterator we will use for vertices 
.br
\fIstd::enable_if_t<std::is_same<glm::vec3*,typename\fP std::iterator_traits<Iterator>::value_type>::value> Iterator template checks 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstartVertices\fP Iterator to the beginning of the vertex list 
.br
 
.br
\fIendVertices\fP Iterator to the end of the vertex list 
.br
\fIdirection\fP The direction vector used to find the farthest point 
.RE
.PP
\fBReturns\fP
.RS 4
glm::vec3* The farthest point with the give direction 
.RE
.PP

.SS "template<typename Iterator , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator>::value_type>::value>, typename Iterator1 , typename  = std::enable_if_t<std::is_same<glm::vec3*, typename std::iterator_traits<Iterator1>::value_type>::value>> static glm::vec3 mtrx::GJKUtil::Support (const Iterator & startVertices1, const Iterator & endVertices1, const Iterator1 & startVertices2, const Iterator1 & endVertices2, const glm::vec3 & direction)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
Support functionality for convex shape collider gives us a point in Minkowski space that is closest to the direction vector given\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIIterator\fP The type of iterator we will use for vertices 
.br
\fIstd::enable_if_t<std::is_same<glm::vec3*,typename\fP std::iterator_traits<Iterator>::value_type>::value> Iterator template checks 
.br
\fIIterator1\fP The type of iterator we will use for vertices 
.br
\fIstd::enable_if_t<std::is_same<glm::vec3*,typename\fP std::iterator_traits<Iterator1>::value_type>::value> Iterator template checks 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstartVertices1\fP Iterator to the beginning of the first vertex list for first convex shape 
.br
\fIendVertices1\fP Iterator to the end of the first vertex list of the first convex shape 
.br
\fIstartVertices2\fP Iterator to the beginning of the second vertex list for the second convex shape 
.br
\fIendVertices2\fP Iterator to the end of the second vertex list of the second convex shape 
.br
 
.br
\fIdirection\fP The direction that we want to find a vertex in the direction of 
.RE
.PP
\fBReturns\fP
.RS 4
glm::vec3 A vertex in minkowski space in the direction given to be added to the simplex 
.RE
.PP

.SS "static void mtrx::GJKUtil::TetrahedronChecks (\fBSimplex\fP & simplex, glm::vec3 & AO, glm::vec3 & AB, glm::vec3 & AC, glm::vec3 & ABC, glm::vec3 & direction, glm::vec3 & a)\fC [static]\fP, \fC [private]\fP"

.PP
Utility function for updating tetrahedron simplex knowing that there is no collision\&. 
.PP
\fBParameters\fP
.RS 4
\fIsimplex\fP The simplex that we want to modify 
.br
\fIAO\fP Line of the triangle 'AO' 
.br
\fIAB\fP Line of the triangle 'AB' 
.br
\fIAC\fP Line of the triangle 'AC' 
.br
\fIABC\fP normal of the the plane ABC of the triangle 
.br
\fIdirection\fP The direction vector of the search 
.br
\fIa\fP The new vector from the support functionality 
.RE
.PP
\fBSee also\fP
.RS 4
\fBmtrx::GJKUtil::Support\fP 
.RE
.PP

.SS "static bool mtrx::GJKUtil::TetrahedronSimplexUpdate (\fBSimplex\fP & simplex, glm::vec3 & direction, glm::vec3 & a)\fC [static]\fP, \fC [private]\fP"

.PP
Update the simplex based upon a tetrahedron simplex\&. 
.PP
\fBParameters\fP
.RS 4
\fIsimplex\fP The simplex we want to update 
.br
\fIdirection\fP The direction that we are searching with 
.br
\fIa\fP The new vertex generated from the support function 
.RE
.PP
\fBSee also\fP
.RS 4
\fBmtrx::GJKUtil::Support\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true The tetrahedron encapsulate the origin signifying a collision 
.PP
false The tetrahedron does not encapsulate the origin and thus the simplex needs to be modified or recalculated 
.RE
.PP

.SS "static bool mtrx::GJKUtil::TriangleSimplexUpdate (\fBSimplex\fP & simplex, glm::vec3 & direction, glm::vec3 & a)\fC [static]\fP, \fC [private]\fP"

.PP
Updating the simplex values from a triangle simplex\&. 
.PP
\fBParameters\fP
.RS 4
\fIsimplex\fP The simplex we want to update 
.br
\fIdirection\fP The direction for the search 
.br
\fIa\fP The new vector that we got from the support function 
.RE
.PP
\fBSee also\fP
.RS 4
\fBmtrx::GJKUtil::Support\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true N/A as a triangle simplex cannot encapsulate a point in 3d space 
.PP
false Always returned 
.RE
.PP

.SS "static bool mtrx::GJKUtil::UpdateSimplex (\fBSimplex\fP & simplex, glm::vec3 & direction, glm::vec3 & a)\fC [static]\fP, \fC [private]\fP"

.PP
Update the simplex values or return a collision\&. 
.PP
\fBParameters\fP
.RS 4
\fIsimplex\fP The simplex generated to be modified according the the new vertices 
.br
\fIdirection\fP The direction that we will be finding points using 
.br
\fIa\fP The newest point to be added to the simplex 
.RE
.PP
\fBReturns\fP
.RS 4
true The simplex encapsulates the origin and thus there exists a collision 
.PP
false The simplex does not encapsule the origin and thus modified the simplex to continue search 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for MTRX Engine from the source code\&.
