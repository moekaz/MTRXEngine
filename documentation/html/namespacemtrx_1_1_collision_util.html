<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTRX Engine: mtrx::CollisionUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTRX Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtrx.html">mtrx</a></li><li class="navelem"><a class="el" href="namespacemtrx_1_1_collision_util.html">CollisionUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mtrx::CollisionUtil Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace used to define some collision detection algorithms that are used to check for collision between different colliders. None of these functions require colliders themselves, They use mostly primitive classes instead.  
<a href="namespacemtrx_1_1_collision_util.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25655a61b608ba45dbd96e1bbdcbcb37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a25655a61b608ba45dbd96e1bbdcbcb37">SphereSphereCollision</a> (const glm::vec3 &amp;center1, const glm::vec3 &amp;center2, float radius1, float radius2)</td></tr>
<tr class="memdesc:a25655a61b608ba45dbd96e1bbdcbcb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere Sphere collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a25655a61b608ba45dbd96e1bbdcbcb37">More...</a><br /></td></tr>
<tr class="separator:a25655a61b608ba45dbd96e1bbdcbcb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058033b88ee093be57383c8e83cd11af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a058033b88ee093be57383c8e83cd11af">SphereCapsuleCollision</a> (const glm::vec3 &amp;center1, const glm::vec3 &amp;center2, float radius1, float radius2, const glm::vec3 &amp;A, const glm::vec3 &amp;B)</td></tr>
<tr class="memdesc:a058033b88ee093be57383c8e83cd11af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere Capsule collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a058033b88ee093be57383c8e83cd11af">More...</a><br /></td></tr>
<tr class="separator:a058033b88ee093be57383c8e83cd11af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7d2a9972902c2bb02ea8bd304c78e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#afb7d2a9972902c2bb02ea8bd304c78e7">SphereAABBCollision</a> (const glm::vec3 &amp;center, const float radius, const glm::vec3 &amp;center1, const float *halfExtents)</td></tr>
<tr class="memdesc:afb7d2a9972902c2bb02ea8bd304c78e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere AABB collider collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#afb7d2a9972902c2bb02ea8bd304c78e7">More...</a><br /></td></tr>
<tr class="separator:afb7d2a9972902c2bb02ea8bd304c78e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad6fd1b06278cf9d1dda3b2e39de83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a5bad6fd1b06278cf9d1dda3b2e39de83">SphereOOBBCollision</a> (const glm::vec3 &amp;center, const float radius, const glm::vec3 &amp;center1, const glm::vec3 *axes, const float *halfExtents)</td></tr>
<tr class="memdesc:a5bad6fd1b06278cf9d1dda3b2e39de83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere OOBB collider collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a5bad6fd1b06278cf9d1dda3b2e39de83">More...</a><br /></td></tr>
<tr class="separator:a5bad6fd1b06278cf9d1dda3b2e39de83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3bc9990e9c0e816aeae56126aaaa25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a7d3bc9990e9c0e816aeae56126aaaa25">CapsuleCapsuleCollision</a> (const glm::vec3 &amp;A1, const glm::vec3 &amp;B1, const glm::vec3 &amp;A2, const glm::vec3 &amp;B2, float radius1, float radius2)</td></tr>
<tr class="memdesc:a7d3bc9990e9c0e816aeae56126aaaa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capsule Capsule collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a7d3bc9990e9c0e816aeae56126aaaa25">More...</a><br /></td></tr>
<tr class="separator:a7d3bc9990e9c0e816aeae56126aaaa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0847bd3390425b25ff591aa74f1f412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#ac0847bd3390425b25ff591aa74f1f412">CapsuleAABBCollision</a> (const glm::vec3 &amp;A, const glm::vec3 &amp;B, const float radii, const glm::vec3 &amp;center, const float *halfExtents)</td></tr>
<tr class="memdesc:ac0847bd3390425b25ff591aa74f1f412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capsule AABB collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#ac0847bd3390425b25ff591aa74f1f412">More...</a><br /></td></tr>
<tr class="separator:ac0847bd3390425b25ff591aa74f1f412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6358f639b903628ca5addc5ff1a451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a5f6358f639b903628ca5addc5ff1a451">AABBCollision</a> (const glm::vec3 &amp;center, const float *halfExtents, const glm::vec3 &amp;center1, const float *halfExtents1)</td></tr>
<tr class="memdesc:a5f6358f639b903628ca5addc5ff1a451"><td class="mdescLeft">&#160;</td><td class="mdescRight">AABB AABB collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a5f6358f639b903628ca5addc5ff1a451">More...</a><br /></td></tr>
<tr class="separator:a5f6358f639b903628ca5addc5ff1a451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98a1e19066de38a68db34e6c183a7c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3a98a1e19066de38a68db34e6c183a7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c">ConvexShapeCollision</a> (const Iterator &amp;startVertices1, const Iterator &amp;endVertices1, const Iterator1 &amp;startVertices2, const Iterator1 &amp;endVertices2)</td></tr>
<tr class="memdesc:a3a98a1e19066de38a68db34e6c183a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convex Shape collision detection algorithm. Uses GJK collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c">More...</a><br /></td></tr>
<tr class="separator:a3a98a1e19066de38a68db34e6c183a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efc8de6ee21149f34b5e7cd77fe1a2c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8efc8de6ee21149f34b5e7cd77fe1a2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a8efc8de6ee21149f34b5e7cd77fe1a2c">ConvexShapeCapsuleCollision</a> (const Iterator &amp;startVertices, const Iterator &amp;endVertices, const int size, const glm::vec3 &amp;A, const glm::vec3 &amp;B, const float radii)</td></tr>
<tr class="memdesc:a8efc8de6ee21149f34b5e7cd77fe1a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convex Shape Capsule collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a8efc8de6ee21149f34b5e7cd77fe1a2c">More...</a><br /></td></tr>
<tr class="separator:a8efc8de6ee21149f34b5e7cd77fe1a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871e293d9a5b8a3a07f5d98fa927743a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a871e293d9a5b8a3a07f5d98fa927743a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a871e293d9a5b8a3a07f5d98fa927743a">CapsuleOOBBCollision</a> (const glm::vec3 &amp;A, const glm::vec3 &amp;B, float radii, const Iterator &amp;startVertices, const Iterator &amp;endVertices, const int size)</td></tr>
<tr class="memdesc:a871e293d9a5b8a3a07f5d98fa927743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capsule OOBB Collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a871e293d9a5b8a3a07f5d98fa927743a">More...</a><br /></td></tr>
<tr class="separator:a871e293d9a5b8a3a07f5d98fa927743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e108082c43adf2c015f65f7b75830f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a63e108082c43adf2c015f65f7b75830f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a63e108082c43adf2c015f65f7b75830f">AABBOOBBCollision</a> (const Iterator &amp;startVertices1, const Iterator &amp;endVertices1, const Iterator1 &amp;startVertices2, const Iterator1 &amp;endVertices2)</td></tr>
<tr class="memdesc:a63e108082c43adf2c015f65f7b75830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">AABB and OOBB collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a63e108082c43adf2c015f65f7b75830f">More...</a><br /></td></tr>
<tr class="separator:a63e108082c43adf2c015f65f7b75830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b40f189ad059f0366228ec61d5cb4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a389b40f189ad059f0366228ec61d5cb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a389b40f189ad059f0366228ec61d5cb4">OOBBCollision</a> (const Iterator &amp;startVertices1, const Iterator &amp;endVertices1, const Iterator1 &amp;startVertices2, const Iterator1 &amp;endVertices2)</td></tr>
<tr class="memdesc:a389b40f189ad059f0366228ec61d5cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">OOBB and OOBB collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a389b40f189ad059f0366228ec61d5cb4">More...</a><br /></td></tr>
<tr class="separator:a389b40f189ad059f0366228ec61d5cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244615348b7ba8a7733587cdd3a2ca7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4244615348b7ba8a7733587cdd3a2ca7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemtrx_1_1_collision_util.html#a4244615348b7ba8a7733587cdd3a2ca7">ConvexShapeSphereCollision</a> (const Iterator &amp;startVertices, const Iterator &amp;endVertices, const int size, const glm::vec3 &amp;center, const float radius)</td></tr>
<tr class="memdesc:a4244615348b7ba8a7733587cdd3a2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convex Shape Sphere collision detection algorithm.  <a href="namespacemtrx_1_1_collision_util.html#a4244615348b7ba8a7733587cdd3a2ca7">More...</a><br /></td></tr>
<tr class="separator:a4244615348b7ba8a7733587cdd3a2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace used to define some collision detection algorithms that are used to check for collision between different colliders. None of these functions require colliders themselves, They use mostly primitive classes instead. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5f6358f639b903628ca5addc5ff1a451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6358f639b903628ca5addc5ff1a451">&#9670;&nbsp;</a></span>AABBCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::AABBCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>halfExtents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>halfExtents1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AABB AABB collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the first AABB collider </td></tr>
    <tr><td class="paramname">halfExtents</td><td>Half extents of the first AABB collider </td></tr>
    <tr><td class="paramname">center1</td><td>Center of the second AABB collider </td></tr>
    <tr><td class="paramname">halfExtents1</td><td>Half extents of the second AABB collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The AABB colliders collide </dd>
<dd>
false The AABB colliders do not collide </dd></dl>

</div>
</div>
<a id="a63e108082c43adf2c015f65f7b75830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e108082c43adf2c015f65f7b75830f">&#9670;&nbsp;</a></span>AABBOOBBCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::AABBOOBBCollision </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>startVertices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>endVertices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AABB and OOBB collision detection algorithm. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm.">mtrx::CollisionUtil::ConvexShapeCollision</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
    <tr><td class="paramname">Iterator1</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertices1</td><td>Iterator to the beginning of the vertex list of the AABB </td></tr>
    <tr><td class="paramname">endVertices1</td><td>Iterator to the end of the vertex list of the AABB </td></tr>
    <tr><td class="paramname">startVertices2</td><td>Iterator to the beginning of the vertex list of the OOBB </td></tr>
    <tr><td class="paramname">endVertices2</td><td>Iterator to the end of the vertex list of the OOBB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The AABB and OOBB colliders collide </dd>
<dd>
false The AABB and OOBB colliders do not collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a63e108082c43adf2c015f65f7b75830f_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a63e108082c43adf2c015f65f7b75830f_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a63e108082c43adf2c015f65f7b75830f_cgraph" id="namespacemtrx_1_1_collision_util_a63e108082c43adf2c015f65f7b75830f_cgraph">
<area shape="rect" title="AABB and OOBB collision detection algorithm." alt="" coords="5,64,159,105"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm." alt="" coords="207,64,365,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a0676f37bb47ba75595fda8cab87d1a25" title="Implementation of GJK Collision detection algorithm." alt="" coords="413,71,571,98"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a2f7779fb20f5aed2ed712c490fc1434d" title="Support functionality for convex shape collider gives us a point in Minkowski space that is closest t..." alt="" coords="640,13,793,39"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a82b7dc1049d74ce11316522e047e28b5" title="Implementation of triple cross product." alt="" coords="651,64,782,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a9e68403818421587aac7e036d5aeb201" title="Update the simplex values or return a collision." alt="" coords="619,130,815,157"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a97c239cfe54183c4424054070a63b8d2" title="Get a point in the vertex list that is closest (direction&#45;wise) to the direction vector." alt="" coords="863,5,1049,47"/>
</map>
</div>

</div>
</div>
<a id="ac0847bd3390425b25ff591aa74f1f412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0847bd3390425b25ff591aa74f1f412">&#9670;&nbsp;</a></span>CapsuleAABBCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::CapsuleAABBCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>halfExtents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capsule AABB collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Center of the topmost sphere for capsule </td></tr>
    <tr><td class="paramname">B</td><td>Center of the bottommost sphere for capsule </td></tr>
    <tr><td class="paramname">radii</td><td>Radii of the capsule </td></tr>
    <tr><td class="paramname">center</td><td>Center of the AABB collider </td></tr>
    <tr><td class="paramname">halfExtents</td><td>Half extents of the AABB collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The capsule and AABB colliders collide </dd>
<dd>
false The capsule and AABB colliders do not collide </dd></dl>

</div>
</div>
<a id="a7d3bc9990e9c0e816aeae56126aaaa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3bc9990e9c0e816aeae56126aaaa25">&#9670;&nbsp;</a></span>CapsuleCapsuleCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::CapsuleCapsuleCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capsule Capsule collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A1</td><td>Center of topmost sphere for first capsule </td></tr>
    <tr><td class="paramname">B1</td><td>Center of bottommost sphere for first capsule </td></tr>
    <tr><td class="paramname">A2</td><td>Center of topmost sphere for second capsule </td></tr>
    <tr><td class="paramname">B2</td><td>Center of bottommost sphere for second capsule </td></tr>
    <tr><td class="paramname">radius1</td><td>Radius of first capsule </td></tr>
    <tr><td class="paramname">radius2</td><td>Radius of second capsule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Capsule colliders collide </dd>
<dd>
false Capsule colliders do not collide </dd></dl>

</div>
</div>
<a id="a871e293d9a5b8a3a07f5d98fa927743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871e293d9a5b8a3a07f5d98fa927743a">&#9670;&nbsp;</a></span>CapsuleOOBBCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::CapsuleOOBBCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capsule OOBB Collision detection algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Center of topmost sphere of capsule collider </td></tr>
    <tr><td class="paramname">B</td><td>Center of bottommost sphere of capsule collider </td></tr>
    <tr><td class="paramname">radii</td><td>Radii of the capsule collider </td></tr>
    <tr><td class="paramname">startVertices</td><td>Iterator to the beginning of the vertices list </td></tr>
    <tr><td class="paramname">endVertices</td><td>Iterator to the end of the vertices list </td></tr>
    <tr><td class="paramname">size</td><td>Number of vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The capsule and OOBB colliders collide </dd>
<dd>
false The capsule and OOBB colliders do not collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a871e293d9a5b8a3a07f5d98fa927743a_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a871e293d9a5b8a3a07f5d98fa927743a_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a871e293d9a5b8a3a07f5d98fa927743a_cgraph" id="namespacemtrx_1_1_collision_util_a871e293d9a5b8a3a07f5d98fa927743a_cgraph">
<area shape="rect" title="Capsule OOBB Collision detection algorithm." alt="" coords="5,50,169,91"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a8efc8de6ee21149f34b5e7cd77fe1a2c" title="Convex Shape Capsule collision detection algorithm." alt="" coords="217,50,423,91"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a26f7db1dab57d281e712b87f058beda4" title="Minimum distance squared of line segment and triangle. The square of the minimum distance is used for..." alt="" coords="471,5,689,61"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a0e6250e1e574e74da2a60d898246dba7" title="Triangulating a convex shape by fan triangulation which is using the first vertex as a starting point..." alt="" coords="498,86,662,127"/>
</map>
</div>

</div>
</div>
<a id="a8efc8de6ee21149f34b5e7cd77fe1a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efc8de6ee21149f34b5e7cd77fe1a2c">&#9670;&nbsp;</a></span>ConvexShapeCapsuleCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::ConvexShapeCapsuleCollision </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radii</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convex Shape Capsule collision detection algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertices</td><td>Iterator to the beginning of the vertex list </td></tr>
    <tr><td class="paramname">endVertices</td><td>Iterator to the end of the vertex list </td></tr>
    <tr><td class="paramname">size</td><td>Number of vertices </td></tr>
    <tr><td class="paramname">A</td><td>Center of the topmost sphere in the capsule collider </td></tr>
    <tr><td class="paramname">B</td><td>Center of the bottommost sphere in the capsule collider </td></tr>
    <tr><td class="paramname">radii</td><td>Radii of the capsule collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The convex shape and capsule colliders collide </dd>
<dd>
false The convex shape and capsule colliders collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_cgraph" id="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_cgraph">
<area shape="rect" title="Convex Shape Capsule collision detection algorithm." alt="" coords="5,50,211,91"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a26f7db1dab57d281e712b87f058beda4" title="Minimum distance squared of line segment and triangle. The square of the minimum distance is used for..." alt="" coords="259,5,477,61"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a0e6250e1e574e74da2a60d898246dba7" title="Triangulating a convex shape by fan triangulation which is using the first vertex as a starting point..." alt="" coords="286,86,450,127"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_icgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_icgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_icgraph" id="namespacemtrx_1_1_collision_util_a8efc8de6ee21149f34b5e7cd77fe1a2c_icgraph">
<area shape="rect" title="Convex Shape Capsule collision detection algorithm." alt="" coords="217,5,423,47"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a871e293d9a5b8a3a07f5d98fa927743a" title="Capsule OOBB Collision detection algorithm." alt="" coords="5,5,169,47"/>
</map>
</div>

</div>
</div>
<a id="a3a98a1e19066de38a68db34e6c183a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a98a1e19066de38a68db34e6c183a7c">&#9670;&nbsp;</a></span>ConvexShapeCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::ConvexShapeCollision </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>startVertices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>endVertices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convex Shape collision detection algorithm. Uses GJK collision detection algorithm. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmtrx_1_1_g_j_k_util.html" title="Utility class for the implementation of the GJK algorithm used for collision detection between convex...">mtrx::GJKUtil</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
    <tr><td class="paramname">Iterator1</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertices1</td><td>Iterator to the beginning of the vertex list for first convex collider </td></tr>
    <tr><td class="paramname">endVertices1</td><td>Iterator to the end of the vertex list for first convex collider </td></tr>
    <tr><td class="paramname">startVertices2</td><td>Iterator to the beginning of the vertex list for the second convex shape collider </td></tr>
    <tr><td class="paramname">endVertices2</td><td>Iterator to the end of the vertex list for the second convex shape collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The convex shape colliders collide </dd>
<dd>
false The convex shape colliders do not collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_cgraph" id="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_cgraph">
<area shape="rect" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm." alt="" coords="5,64,164,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a0676f37bb47ba75595fda8cab87d1a25" title="Implementation of GJK Collision detection algorithm." alt="" coords="212,71,369,98"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a2f7779fb20f5aed2ed712c490fc1434d" title="Support functionality for convex shape collider gives us a point in Minkowski space that is closest t..." alt="" coords="439,13,592,39"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a82b7dc1049d74ce11316522e047e28b5" title="Implementation of triple cross product." alt="" coords="450,64,581,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a9e68403818421587aac7e036d5aeb201" title="Update the simplex values or return a collision." alt="" coords="417,130,613,157"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a97c239cfe54183c4424054070a63b8d2" title="Get a point in the vertex list that is closest (direction&#45;wise) to the direction vector." alt="" coords="661,5,848,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_icgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_icgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_icgraph" id="namespacemtrx_1_1_collision_util_a3a98a1e19066de38a68db34e6c183a7c_icgraph">
<area shape="rect" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm." alt="" coords="207,39,365,80"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a63e108082c43adf2c015f65f7b75830f" title="AABB and OOBB collision detection algorithm." alt="" coords="5,5,159,47"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a389b40f189ad059f0366228ec61d5cb4" title="OOBB and OOBB collision detection algorithm." alt="" coords="20,71,144,112"/>
</map>
</div>

</div>
</div>
<a id="a4244615348b7ba8a7733587cdd3a2ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4244615348b7ba8a7733587cdd3a2ca7">&#9670;&nbsp;</a></span>ConvexShapeSphereCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::ConvexShapeSphereCollision </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convex Shape Sphere collision detection algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertices</td><td>Iterator to the beginning of the vertex list of the convex shape </td></tr>
    <tr><td class="paramname">endVertices</td><td>Iterator to the end of the vertex list of the convex shape </td></tr>
    <tr><td class="paramname">size</td><td>Number of vertices of convex shape collider </td></tr>
    <tr><td class="paramname">center</td><td>Center of the sphere collider </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the sphere collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The convex shape and sphere colliders collide </dd>
<dd>
false The convex shape and sphere colliders do not collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a4244615348b7ba8a7733587cdd3a2ca7_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a4244615348b7ba8a7733587cdd3a2ca7_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a4244615348b7ba8a7733587cdd3a2ca7_cgraph" id="namespacemtrx_1_1_collision_util_a4244615348b7ba8a7733587cdd3a2ca7_cgraph">
<area shape="rect" title="Convex Shape Sphere collision detection algorithm." alt="" coords="5,39,204,80"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a8adf3f94936a17666f63e28d96335559" title="Minimum distance squared between a point and triangle. The square of the minimum distance is used for..." alt="" coords="252,5,469,47"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a0e6250e1e574e74da2a60d898246dba7" title="Triangulating a convex shape by fan triangulation which is using the first vertex as a starting point..." alt="" coords="279,71,443,112"/>
</map>
</div>

</div>
</div>
<a id="a389b40f189ad059f0366228ec61d5cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b40f189ad059f0366228ec61d5cb4">&#9670;&nbsp;</a></span>OOBBCollision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt;, typename Iterator1 , typename  = std::enable_if_t&lt;std::is_same&lt;glm::vec3*, typename std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::OOBBCollision </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>startVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>endVertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>startVertices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator1 &amp;&#160;</td>
          <td class="paramname"><em>endVertices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OOBB and OOBB collision detection algorithm. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm.">mtrx::CollisionUtil::ConvexShapeCollision</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
    <tr><td class="paramname">Iterator1</td><td>An iterator type for the data structure that holds the vertices </td></tr>
    <tr><td class="paramname">std::enable_if_t&lt;std::is_same&lt;glm::vec3*,typename</td><td>std::iterator_traits&lt;Iterator1&gt;::value_type&gt;::value&gt; Template parameter check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertices1</td><td>Iterator to the beginning of the vertex list of the first OOBB </td></tr>
    <tr><td class="paramname">endVertices1</td><td>Iterator to the end of the vertex list of the first OOBB </td></tr>
    <tr><td class="paramname">startVertices2</td><td>Iterator to the beginning of the vertex list of the second OOBB </td></tr>
    <tr><td class="paramname">endVertices2</td><td>Iterator to the end of the vertex list of the second OOBB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The OOBB colliders collide </dd>
<dd>
false The OOBB colliders do not collide </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacemtrx_1_1_collision_util_a389b40f189ad059f0366228ec61d5cb4_cgraph.png" border="0" usemap="#namespacemtrx_1_1_collision_util_a389b40f189ad059f0366228ec61d5cb4_cgraph" alt=""/></div>
<map name="namespacemtrx_1_1_collision_util_a389b40f189ad059f0366228ec61d5cb4_cgraph" id="namespacemtrx_1_1_collision_util_a389b40f189ad059f0366228ec61d5cb4_cgraph">
<area shape="rect" title="OOBB and OOBB collision detection algorithm." alt="" coords="5,64,129,105"/>
<area shape="rect" href="namespacemtrx_1_1_collision_util.html#a3a98a1e19066de38a68db34e6c183a7c" title="Convex Shape collision detection algorithm. Uses GJK collision detection algorithm." alt="" coords="177,64,336,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a0676f37bb47ba75595fda8cab87d1a25" title="Implementation of GJK Collision detection algorithm." alt="" coords="384,71,541,98"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a2f7779fb20f5aed2ed712c490fc1434d" title="Support functionality for convex shape collider gives us a point in Minkowski space that is closest t..." alt="" coords="611,13,764,39"/>
<area shape="rect" href="namespacemtrx_1_1_physics_util.html#a82b7dc1049d74ce11316522e047e28b5" title="Implementation of triple cross product." alt="" coords="622,64,753,105"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a9e68403818421587aac7e036d5aeb201" title="Update the simplex values or return a collision." alt="" coords="589,130,785,157"/>
<area shape="rect" href="classmtrx_1_1_g_j_k_util.html#a97c239cfe54183c4424054070a63b8d2" title="Get a point in the vertex list that is closest (direction&#45;wise) to the direction vector." alt="" coords="833,5,1020,47"/>
</map>
</div>

</div>
</div>
<a id="afb7d2a9972902c2bb02ea8bd304c78e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7d2a9972902c2bb02ea8bd304c78e7">&#9670;&nbsp;</a></span>SphereAABBCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::SphereAABBCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>halfExtents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere AABB collider collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the sphere collider </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the sphere collider </td></tr>
    <tr><td class="paramname">center1</td><td>Center of the AABB collider </td></tr>
    <tr><td class="paramname">halfExtents</td><td>Half Extents of the AABB collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The sphere and AABB colliders collide </dd>
<dd>
false The sphere and AABB colliders do not collide </dd></dl>

</div>
</div>
<a id="a058033b88ee093be57383c8e83cd11af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058033b88ee093be57383c8e83cd11af">&#9670;&nbsp;</a></span>SphereCapsuleCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::SphereCapsuleCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere Capsule collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center1</td><td>Center of the sphere collider </td></tr>
    <tr><td class="paramname">center2</td><td>Center of the capsule collider </td></tr>
    <tr><td class="paramname">radius1</td><td>Radius of the sphere collider </td></tr>
    <tr><td class="paramname">radius2</td><td>Radius of the capsule collider </td></tr>
    <tr><td class="paramname">A</td><td>Topmost sphere center for capsule collider </td></tr>
    <tr><td class="paramname">B</td><td>Bottommost sphere center for capsule collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The sphere and capsule colliders collide </dd>
<dd>
false The sphere and capsule colliders do not collide </dd></dl>

</div>
</div>
<a id="a5bad6fd1b06278cf9d1dda3b2e39de83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bad6fd1b06278cf9d1dda3b2e39de83">&#9670;&nbsp;</a></span>SphereOOBBCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::SphereOOBBCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 *&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>halfExtents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere OOBB collider collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the sphere collider </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the sphere collider </td></tr>
    <tr><td class="paramname">center1</td><td>Center of the OOBB collider </td></tr>
    <tr><td class="paramname">axes</td><td>Axes that define the OOBB world </td></tr>
    <tr><td class="paramname">halfExtents</td><td>Half extent values of OOBB colliders </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Sphere and OOBB colliders collide </dd>
<dd>
false Sphere and OOBB colliders do not collide </dd></dl>

</div>
</div>
<a id="a25655a61b608ba45dbd96e1bbdcbcb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25655a61b608ba45dbd96e1bbdcbcb37">&#9670;&nbsp;</a></span>SphereSphereCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mtrx::CollisionUtil::SphereSphereCollision </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere Sphere collision detection algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center1</td><td>Center of the first sphere collider </td></tr>
    <tr><td class="paramname">center2</td><td>Center of the second sphere collider </td></tr>
    <tr><td class="paramname">radius1</td><td>Radius of the first sphere collider </td></tr>
    <tr><td class="paramname">radius2</td><td>Radius of the second sphere collider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The 2 sphere colliders collide </dd>
<dd>
false The 2 sphere colliders do not collide </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
